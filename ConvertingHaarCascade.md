# Converting the Haar cascade #

The Haar cascades generate by the OpenCV are XML files containing a tree structure and floating-point weights denoting the constants resulting from each stage of the cascade. Several files are provided with the OpenCV in the directory data/haarcascades. File sizes in that directory run from several hundred kilobytes to a few megabytes.

There are XML parsers available for J2ME (for an introduction see http://developers.sun.com/mobility/midp/articles/parsingxml/) but the Haar cascades are much too large to fit in a typical cellphone’s memory (e.g., 16 MB) as they are being parsed by a general-purpose XML parser. Moreover, an XML parser would not convert the floating point values in the Haar cascade to fixed point, making it necessary to implement floating point parsing and conversion code in J2ME. Also, the OpenCV implements an extensive set of routines for reading in Haar cascades and converting them to an internal class structure. It makes more sense as a design to take advantage of the OpenCV’s interface to the Haar cascade XML file as far as possible and do the conversion (and very simple compression) before transferring the file to the cellphone.

Haar2J2ME implements this approach. It is based on the “performance” application which ships with the OpenCV. It must be compiled with the OpenCV libraries. The code in haar2j2me.cpp which reads the Haar cascade is taken directly from performance.cpp – the cascade is loaded using cvLoadHaarClassifierCascade.

Once the cascade has been loaded it is converted into another class structure by iteratively reading each stage of the CvHaarStageClassifier created by the OpenCV and converting the floating point coefficients to integer, scaling appropriately. The coefficients chosen for scaling were set based on examination of the sample Haar cascades including in the OpenCV. Given the approximate nature of feature detection, scaling coefficients and converting them to fixed point should be expected to work quite well, and it does.

The resulting tree is written to the standard output using overrides of the << operator in HaarClassifierStumpBase and its related classes. These classes mirror the Java classes implemented in HaarClassifierCascade, which have been previously described.

After conversion the Haar cascade is represented as a simple text file containing a parenthesis-based representation of the tree and integer constants giving the coefficients. To actually transfer the text file containing the Haar cascade the file is simply compiled into the FaceDetect application. This embeds the file as a resource and allows it to be opened using getResourceAsStream (see the DetectHaar constructor in DetectHaarParam). The inputStream returned from getResourceAsStream is passed to DetectHaarMultiScale to initialize the Java representation of the Haar cascade using constructors matching the implementation of the << operators in the Haar2J2ME classes. The resulting representation is efficient and easily fits in a modern cellphone’s memory, requiring at most a few hundred kilobytes for the tree.